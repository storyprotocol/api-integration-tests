# Test info

- Name: List IPAssets @IPAssets >> Should return IPAssets list with pagination {"offset":0,"limit":5}
- Location: /home/runner/work/api-integration-tests/api-integration-tests/tests/api/ipassets/assets.post.spec.ts:45:9

# Error details

```
Error: expect(received).toBe(expected) // Object.is equality

Expected: 200
Received: 530
    at /home/runner/work/api-integration-tests/api-integration-tests/tests/api/ipassets/assets.post.spec.ts:54:33
```

# Test source

```ts
   1 | import { test, expect } from "../fixtures/base";
   2 |
   3 | const endpoint = "./assets";
   4 |
   5 | test.describe("List IPAssets @IPAssets", async () => {
   6 |   test("Should return default IPAssets list", async ({ request }) => {
   7 |     const response = await request.post(endpoint);
   8 |     expect(response.status()).toBe(200);
   9 |
   10 |     const { errors, data } = await response.json();
   11 |     expect(errors).toBeUndefined();
   12 |     expect(Array.isArray(data)).toBeTruthy();
   13 |     expect(data.length).toBeGreaterThan(0);
   14 |     expect(typeof data[0].id).toBe("string");
   15 |     expect(Array.isArray(data[0].parentIpIds ?? [])).toBeTruthy();
   16 |     expect(Array.isArray(data[0].childIpIds ?? [])).toBeTruthy();
   17 |     expect(Array.isArray(data[0].rootIpIds ?? [])).toBeTruthy();
   18 |     expect(typeof data[0].nftMetadata.name).toBe("string");
   19 |     expect(typeof data[0].nftMetadata.chainId).toBe("string");
   20 |     expect(typeof data[0].nftMetadata.tokenId).toBe("string");
   21 |     expect(typeof data[0].nftMetadata.tokenUri).toBe("string");
   22 |     expect(typeof data[0].nftMetadata.imageUrl).toBe("string");
   23 |     expect(typeof data[0].nftMetadata.tokenContract).toBe("string");
   24 |     expect(typeof data[0].blockNumber).toBe("string");
   25 |     expect(typeof data[0].blockTimestamp).toBe("string");
   26 |     expect(data[0].id).toBeTruthy();
   27 |     expect(data[0].nftMetadata.name).toBeTruthy();
   28 |     expect(data[0].nftMetadata.chainId).toBeTruthy();
   29 |     expect(data[0].nftMetadata.tokenId).toBeTruthy();
   30 |     expect(data[0].nftMetadata.tokenContract).toBeTruthy();
   31 |     expect(data[0].blockNumber).toBeTruthy();
   32 |     expect(data[0].blockTimestamp).toBeTruthy();
   33 |     for (let i = 0; i < data.length - 1; i++) {
   34 |       const item = parseInt(data[i].blockTimestamp);
   35 |       const nextItem = parseInt(data[i + 1].blockTimestamp);
   36 |       expect(item).toBeGreaterThanOrEqual(nextItem);
   37 |     }
   38 |   });
   39 |
   40 |   const pageParams = [
   41 |     { pagination: { offset: 0, limit: 5 } },
   42 |     { pagination: { offset: 1, limit: 2 } },
   43 |   ];
   44 |   for (const { pagination } of pageParams) {
   45 |     test(`Should return IPAssets list with pagination ${JSON.stringify(
   46 |       pagination
   47 |     )}`, async ({ request }) => {
   48 |       const payload = {
   49 |         options: { pagination: pagination },
   50 |       };
   51 |       const response = await request.post(endpoint, {
   52 |         data: payload,
   53 |       });
>  54 |       expect(response.status()).toBe(200);
      |                                 ^ Error: expect(received).toBe(expected) // Object.is equality
   55 |
   56 |       const offsetResponse = await request.post(endpoint, {
   57 |         data: { options: { pagination: { limit: 5 } } },
   58 |       });
   59 |       const offsetJson = await offsetResponse.json();
   60 |       const firstItem = offsetJson.data[pagination.offset];
   61 |
   62 |       const { errors, data } = await response.json();
   63 |       expect(errors).toBeUndefined();
   64 |       expect(data.length).toBeLessThanOrEqual(pagination.limit);
   65 |       expect(data[0]).toMatchObject(firstItem);
   66 |     });
   67 |   }
   68 |
   69 |   // const orderParams = [
   70 |   //   { orderBy: "id", orderDirection: "desc" },
   71 |   //   { orderBy: "id", orderDirection: "asc" },
   72 |   //   { orderBy: "blockNumber", orderDirection: "desc" },
   73 |   //   { orderBy: "blockNumber", orderDirection: "asc" },
   74 |   //   { orderBy: "blockTimestamp", orderDirection: "desc" },
   75 |   //   { orderBy: "blockTimestamp", orderDirection: "asc" },
   76 |   // ];
   77 |   // for (const { orderBy, orderDirection } of orderParams) {
   78 |   //   test(`Should return IPAssets list ordered by ${orderBy} ${orderDirection}`, async ({
   79 |   //     request,
   80 |   //   }) => {
   81 |   //     const payload = {
   82 |   //       options: { orderBy: orderBy, orderDirection: orderDirection },
   83 |   //     };
   84 |   //     const response = await request.post(endpoint, {
   85 |   //       data: payload,
   86 |   //     });
   87 |   //     expect(response.status()).toBe(200);
   88 |
   89 |   //     const { errors, data } = await response.json();
   90 |   //     expect(errors).toBeUndefined();
   91 |   //     expect(data.length).toBeGreaterThan(0);
   92 |   //     for (let i = 0; i < data.length - 1; i++) {
   93 |   //       let item = data[i][orderBy].trim() || "\uFFFF";
   94 |   //       let nextItem = data[i + 1][orderBy].trim() || "\uFFFF";
   95 |   //       if(orderBy === "tokenId"){
   96 |   //         item = parseInt(data[i][orderBy]);
   97 |   //         nextItem = parseInt(data[i + 1][orderBy]);
   98 |   //       }
   99 |   //       if (orderDirection === "asc") {
  100 |   //         expect(item <= nextItem).toBeTruthy();
  101 |   //       } else {
  102 |   //         expect(item >= nextItem).toBeTruthy();
  103 |   //       }
  104 |   //     }
  105 |   //   });
  106 |   // }
  107 |
  108 |   test("Should return IPAssets list with filter", async ({
  109 |     request,
  110 |     assets,
  111 |   }) => {
  112 |     const whereParams = [
  113 |       { where: { chainId: assets[1].nftMetadata.chainId }, exists: true },
  114 |       { where: { chainId: "11100111" }, exists: false },
  115 |       { where: { tokenId: assets[2].nftMetadata.tokenId }, exists: true },
  116 |       { where: { tokenId: "99999999" }, exists: false },
  117 |       {
  118 |         where: { tokenContract: assets[2].nftMetadata.tokenContract },
  119 |         exists: true,
  120 |       },
  121 |       {
  122 |         where: { tokenContract: "0xc06189455340139e0edce0744d715ae43176c999" },
  123 |         exists: false,
  124 |       },
  125 |       {
  126 |         where: {
  127 |           chainId: assets[1].nftMetadata.chainId,
  128 |           tokenContract: assets[1].nftMetadata.tokenContract,
  129 |         },
  130 |         exists: true,
  131 |       },
  132 |       {
  133 |         where: {
  134 |           tokenId: "99999999",
  135 |           tokenContract: "0x3809f4128b0b33afb17576edafd7d4f4e2abe933",
  136 |         },
  137 |         exists: false,
  138 |       },
  139 |     ];
  140 |     for (const { where, exists } of whereParams) {
  141 |       await test.step(`Should return IPAssets list with filter ${JSON.stringify(
  142 |         where
  143 |       )}`, async () => {
  144 |         const payload = {
  145 |           options: { where: where },
  146 |         };
  147 |         const response = await request.post(endpoint, {
  148 |           data: payload,
  149 |         });
  150 |         expect(response.status()).toBe(200);
  151 |
  152 |         const { errors, data } = await response.json();
  153 |         expect(errors).toBeUndefined();
  154 |         if (exists) {
```