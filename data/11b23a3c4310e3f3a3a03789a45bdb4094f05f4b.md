# Test info

- Name: List Minting Fees @Licenses Minting Fees >> Should return Minting Fees list with pagination {"offset":1,"limit":4}
- Location: /home/runner/work/api-integration-tests/api-integration-tests/tests/api/licenses/licenses-mintingfees.post.spec.ts:41:9

# Error details

```
Error: expect(received).toBe(expected) // Object.is equality

Expected: 200
Received: 530
    at /home/runner/work/api-integration-tests/api-integration-tests/tests/api/licenses/licenses-mintingfees.post.spec.ts:50:33
```

# Test source

```ts
   1 | import { test, expect } from "../fixtures/base";
   2 |
   3 | const endpoint = "./licenses/mintingfees";
   4 |
   5 | test.describe("List Minting Fees @Licenses Minting Fees", async () => {
   6 |   test("Should return default Minting Fees list", async ({ request }) => {
   7 |     const response = await request.post(endpoint);
   8 |     expect(response.status()).toBe(200);
   9 |
   10 |     const { errors, data } = await response.json();
   11 |     expect(errors).toBeUndefined();
   12 |     expect(Array.isArray(data)).toBeTruthy();
   13 |     expect(data.length).toBeGreaterThan(0);
   14 |     expect(typeof data[0].id).toBe("string");
   15 |     expect(typeof data[0].token).toBe("string");
   16 |     expect(typeof data[0].payer).toBe("string");
   17 |     expect(typeof data[0].amount).toBe("string");
   18 |     expect(typeof data[0].receiverIpId).toBe("string");
   19 |     expect(typeof data[0].blockNumber).toBe("string");
   20 |     expect(typeof data[0].blockTimestamp).toBe("string");
   21 |     expect(data[0].id).toBeTruthy();
   22 |     expect(data[0].token).toBeTruthy();
   23 |     expect(data[0].payer).toBeTruthy();
   24 |     expect(data[0].amount).toBeTruthy();
   25 |     expect(data[0].receiverIpId).toBeTruthy();
   26 |     expect(data[0].blockNumber).toBeTruthy();
   27 |     expect(data[0].blockTimestamp).toBeTruthy();
   28 |     for (let i = 0; i < data.length - 1; i++) {
   29 |       const item = parseInt(data[i].blockTimestamp);
   30 |       const nextItem = parseInt(data[i + 1].blockTimestamp);
   31 |       expect(item).toBeGreaterThanOrEqual(nextItem);
   32 |     }
   33 |   });
   34 |
   35 |   const pageParams = [
   36 |     { pagination: { offset: 0, limit: 5 } },
   37 |     { pagination: { offset: 1, limit: 4 } },
   38 |     { pagination: { offset: 2, limit: 3 } },
   39 |   ];
   40 |   for (const { pagination } of pageParams) {
   41 |     test(`Should return Minting Fees list with pagination ${JSON.stringify(
   42 |       pagination
   43 |     )}`, async ({ request }) => {
   44 |       const payload = {
   45 |         options: { pagination: pagination },
   46 |       };
   47 |       const response = await request.post(endpoint, {
   48 |         data: payload,
   49 |       });
>  50 |       expect(response.status()).toBe(200);
      |                                 ^ Error: expect(received).toBe(expected) // Object.is equality
   51 |
   52 |       const offsetResponse = await request.post(endpoint, {
   53 |         data: { options: { pagination: { limit: 5 } } },
   54 |       });
   55 |       const offsetJson = await offsetResponse.json();
   56 |       const firstItem = offsetJson.data[payload.options.pagination.offset];
   57 |
   58 |       const { errors, data } = await response.json();
   59 |       expect(errors).toBeUndefined();
   60 |       expect(data.length).toBeLessThanOrEqual(payload.options.pagination.limit);
   61 |       expect(data[0]).toMatchObject(firstItem);
   62 |     });
   63 |   }
   64 |
   65 |   // const orderParams = [
   66 |   //   { orderBy: "id", orderDirection: "desc" },
   67 |   //   { orderBy: "id", orderDirection: "asc" },
   68 |   //   { orderBy: "token", orderDirection: "desc" },
   69 |   //   { orderBy: "token", orderDirection: "asc" },
   70 |   //   { orderBy: "payer", orderDirection: "desc" },
   71 |   //   { orderBy: "payer", orderDirection: "asc" },
   72 |   //   { orderBy: "amount", orderDirection: "desc" },
   73 |   //   { orderBy: "amount", orderDirection: "asc" },
   74 |   //   { orderBy: "receiverIpId", orderDirection: "desc" },
   75 |   //   { orderBy: "receiverIpId", orderDirection: "asc" },
   76 |   //   { orderBy: "blockNumber", orderDirection: "desc" },
   77 |   //   { orderBy: "blockNumber", orderDirection: "asc" },
   78 |   //   { orderBy: "blockTimestamp", orderDirection: "desc" },
   79 |   //   { orderBy: "blockTimestamp", orderDirection: "asc" },
   80 |   // ];
   81 |   // for (const { orderBy, orderDirection } of orderParams) {
   82 |   //   test(`Should return Minting Fees list with order by ${orderBy} and order direction ${orderDirection}`, async ({
   83 |   //     request,
   84 |   //   }) => {
   85 |   //     const payload = {
   86 |   //       options: { orderBy, orderDirection },
   87 |   //     };
   88 |   //     const response = await request.post(endpoint, {
   89 |   //       data: payload,
   90 |   //     });
   91 |   //     expect(response.status()).toBe(200);
   92 |
   93 |   //     const { errors, data } = await response.json();
   94 |   //     expect(errors).toBeUndefined();
   95 |   //     expect(data.length).toBeGreaterThan(0);
   96 |   //     for (let i = 0; i < data.length - 1; i++) {
   97 |   //       let item: string | number;
   98 |   //       let nextItem: string | number;
   99 |   //       if (orderBy === "amount") {
  100 |   //         item = parseInt(data[i][orderBy]);
  101 |   //         nextItem = parseInt(data[i + 1][orderBy]);
  102 |   //       } else {
  103 |   //         item = data[i][orderBy].trim() || "\uFFFF";
  104 |   //         nextItem = data[i + 1][orderBy].trim() || "\uFFFF";
  105 |   //       }
  106 |   //       if (orderDirection === "asc") {
  107 |   //         expect(item <= nextItem).toBeTruthy();
  108 |   //       } else {
  109 |   //         expect(item >= nextItem).toBeTruthy();
  110 |   //       }
  111 |   //     }
  112 |   //   });
  113 |   // }
  114 |
  115 |   // const pageAndOrderParams = [
  116 |   //   {
  117 |   //     pagination: { offset: 2, limit: 3 },
  118 |   //     orderBy: "token",
  119 |   //     orderDirection: "desc",
  120 |   //   },
  121 |   //   {
  122 |   //     pagination: { offset: 1, limit: 4 },
  123 |   //     orderBy: "id",
  124 |   //     orderDirection: "asc",
  125 |   //   },
  126 |   // ];
  127 |   // for (const { pagination, orderBy, orderDirection } of pageAndOrderParams) {
  128 |   //   test(`Should return Minting Fees list with pagination ${JSON.stringify(
  129 |   //     pagination
  130 |   //   )} and order by ${orderBy} ${orderDirection}`, async ({ request }) => {
  131 |   //     const payload = {
  132 |   //       options: { pagination, orderBy, orderDirection },
  133 |   //     };
  134 |   //     const response = await request.post(endpoint, {
  135 |   //       data: payload,
  136 |   //     });
  137 |   //     expect(response.status()).toBe(200);
  138 |
  139 |   //     const { errors, data } = await response.json();
  140 |   //     expect(errors).toBeUndefined();
  141 |   //     expect(data.length).toBeGreaterThan(0);
  142 |   //     expect(data.length).toBeLessThanOrEqual(pagination.limit);
  143 |   //     for (let i = 0; i < data.length - 1; i++) {
  144 |   //       const item = data[i][orderBy].trim() || "\uFFFF";
  145 |   //       const nextItem = data[i + 1][orderBy].trim() || "\uFFFF";
  146 |   //       if (orderDirection === "asc") {
  147 |   //         expect(item <= nextItem).toBeTruthy();
  148 |   //       } else {
  149 |   //         expect(item >= nextItem).toBeTruthy();
  150 |   //       }
```